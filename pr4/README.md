# Практична робота №4 

## Завдання 4.1: Максимальний розмір пам'яті, що може виділити malloc(3)

Було проаналізовано, який максимальний обсяг пам'яті може бути виділений за один виклик malloc(3). Оскільки параметр malloc(3) є типу size_t, максимальний розмір визначається максимальною величиною size_t. На 64-бітній системі це 8 байтів (64 біти), що дає максимальний розмір 2^64 байтів (16 ексабайт). 

Однак, теоретично доступна пам'ять обмежена архітектурою процесора та операційною системою. Реальний ліміт значно менший через віртуальну пам'ять та обмеження ядра. 

На питання, чому теоретично максимальний обсяг складає 8 ексабайт, а не 16, відповідь полягає в тому, що сучасні процесори використовують лише 48-57 біт для адресації пам'яті, а не всі 64 біти.


## Завдання 4.2: Використання malloc(3) з від'ємним аргументом

Було досліджено, що станеться при передаванні malloc(3) від'ємного значення. Оскільки malloc(3) приймає size_t (беззнаковий тип), передача від'ємного числа призведе до переповнення та інтерпретації як великого позитивного числа, що спричинить невдале виділення пам'яті. 

Також було розглянуто випадок множення двох цілих чисел (num = xa * xb), де результат може перевищити межі size_t, викликаючи переповнення. malloc(3) у такому випадку може або повернути NULL, або викликати непередбачувану поведінку. Тестовий випадок продемонстрував помилку та необхідність перевірки переповнення перед передачею значення в malloc(3).

## [Код до завдання](Ex2.c)

## Завдання 4.3: Використання malloc(0)

Було протестовано, що станеться, якщо викликати malloc(0). За стандартом C malloc(0) може повернути або NULL, або валідний вказівник, який можна передати free(). Поведінка залежить від реалізації malloc(3) у конкретній бібліотеці C. Тестовий випадок продемонстрував різну поведінку залежно від системи.

## [Код до завдання](Ex3.c)

## Завдання 4.4: Аналіз помилки в коді з malloc(3)

Було проаналізовано наступний код:

```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... використання 'ptr' ...]
    free(ptr);
}
```

Помилка в тому, що ptr звільняється в кожній ітерації, але не скидається в NULL. Це може призвести до повторного використання звільненої пам'яті (use-after-free). Правильний варіант коду:

```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... використання 'ptr' ...]
    free(ptr);
    ptr = NULL;
}
```

## [Код до завдання](Ex4_2.c)


## Завдання 4.5: Якщо realloc(3) не зможе виділити пам'ять

Було протестовано, що станеться, якщо realloc(3) не зможе виділити пам'ять. У такому випадку функція повертає NULL, але старий вказівник не звільняється. Важливо перед перевизначенням ptr = realloc(ptr, new_size); перевіряти, чи не повернув realloc(3) NULL, щоб уникнути втрати старої пам'яті.

## [Код до завдання](Ex5.c)

## Завдання 4.6: Використання realloc(3) з NULL або розміром 0

Було перевірено дві ситуації:
1. realloc(NULL, size) – еквівалент malloc(size). 
2. realloc(ptr, 0) – поводиться як free(ptr), але може повернути або NULL, або валідний вказівник.

Тестування підтвердило таку поведінку, що узгоджується зі стандартом C.

## [Код до завдання](Ex6.c)

## Завдання 4.7: Використання reallocarray(3)

Було переписано код, що використовував realloc(3), замінивши його на reallocarray(3), який перевіряє переповнення множення. 

Було проведено тестування через ltrace, що показало коректну роботу reallocarray(3) без ризику переповнення.

## [Код до завдання](Ex7.c)

## Завдання 15: Дослідження різниці між malloc у glibc та musl

Було проведено порівняльний аналіз реалізацій malloc у двох популярних бібліотеках C: glibc та musl. Для тестування було створено програму, яка виділяє та звільняє значну кількість пам'яті, з вимірюванням використання ресурсів.

### Ключові відмінності реалізацій:

1. **Розмір накладних витрат**: 
   - glibc використовує алгоритм ptmalloc2, який має більші накладні витрати на метадані.
   - musl має оптимізовану реалізацію з меншими накладними витратами, що робить її ефективнішою на вбудованих системах.

2. **Фрагментація пам'яті**:
   - glibc використовує складніші алгоритми для зменшення фрагментації з часом.
   - musl має простішу стратегію розподілу, яка може призвести до більшої фрагментації при інтенсивному використанні.

3. **Багатопотоковість**:
   - glibc має багатопотокову реалізацію з підтримкою арен, що дозволяє різним потокам одночасно виділяти пам'ять.
   - musl використовує єдиний м'ютекс для всіх операцій, що може обмежувати продуктивність у багатопотокових програмах.

4. **Оптимізація швидкості vs пам'яті**:
   - glibc оптимізовано для швидкості на потужних системах.
   - musl оптимізовано для мінімального використання пам'яті, ідеально для вбудованих систем.

### Висновки:

Тестування показало, що musl має менші накладні витрати на метадані та ефективніше звільняє пам'ять системі. glibc демонструє кращу продуктивність у випадках інтенсивного використання пам'яті та багатопотокового середовища. Вибір між ними залежить від вимог до програми: для вбудованих систем з обмеженими ресурсами краще підходить musl, тоді як для великих серверних програм glibc може забезпечити кращу загальну продуктивність.

## [Код до завдання](Var15.c)

## Висновок

Правильне керування пам'яттю є критично важливим для стабільної та ефективної роботи програм. Використання malloc(3), realloc(3), calloc(3) та reallocarray(3) вимагає перевірки їхніх результатів та обережного поводження для запобігання витокам пам'яті, переповненню та use-after-free помилкам. reallocarray(3) забезпечує безпечніше виділення пам'яті. Різні реалізації бібліотек C, як-от glibc та musl, мають власні підходи до управління пам'яттю, що впливає на продуктивність та використання ресурсів. Тестування різних випадків виявило потенційні проблеми та дозволило розробити коректні рішення.